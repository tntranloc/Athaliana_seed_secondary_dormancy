library(biomod2)
library(raster)
library(rasterVis)
library(terra)
library(sp)
library(geodata) # in case raster::getData doesn't work

#get data
#datsp have columns with species names and their presence, absence
#assign 1 for presence, 0 for absence

#datsp also has longitude, latitude together with species presence(/absence)


#get climate data
biocur <- getData("worldclim",var="bio",res=10) 
eu_ext <- c(-10, 40, 34, 70)
biocur <- crop(biocur, eu_ext) 
biocur

#define these variables for biomod formating data 
myExpl <- stack(biocur$bio9,biocur$bio10,biocur$bio18)  #because raster stack or layer is required by biomod
myRespName <- "Athaliana" #for example
myResp <- as.numeric(datsp[,"Athaliana"])
myRespXY <- datsp[,c("Longitude","Latitude")]


#format dataset with BIOMOD_FormatingData
#if you need to create pseudo absences, the number of pseudo-absence should be roughly the same as your presence
dim(datsp) 
myBiomodData <- BIOMOD_FormatingData(resp.var = myResp,
                                     expl.var = myExpl,
                                     resp.xy = myRespXY,
                                     resp.name = myRespName,
                                     PA.nb.rep = 3,
                                     PA.nb.absences = 181,
                                     PA.strategy = "random")


myBiomodData
plot(myBiomodData)

myBiomodOption <- BIOMOD_ModelingOptions()

###RUN INDIVIDUAL MODELS
#data split 80 means 70% used for train data and 30% for test data
myBiomodModelOut <- BIOMOD_Modeling(
  myBiomodData,
  models = c('GLM','GAM','RF'),
  bm.options = myBiomodOption,
  nb.rep=3,
  data.split.perc=80,
  var.import=3,
  metric.eval = c('TSS','ROC','KAPPA'),
  save.output = TRUE,
  scale.models  = TRUE,
  do.full.models = FALSE,
  modeling.id = paste(myRespName,"FirstModeling",sep=""))


# get all models evaluation
myBiomodModelEval <- get_evaluations(myBiomodModelOut)
# print the dimnames of this object
dim(myBiomodModelEval)
dimnames(myBiomodModelEval)

#let's print the TSS scores of Random Forest and of all models
myBiomodModelEval["TSS","Testing.data","RF",,]
myBiomodModelEval["TSS","Testing.data",,,]
# let's print the ROC scores of all models
myBiomodModelEval["ROC","Testing.data",,,]
# let's print the KAPPA scores of all models
myBiomodModelEval["KAPPA","Testing.data",,,]


#plot model scores
par(mfrow=c(1,3))
bm_PlotEvalBoxplot(bm.out = myBiomodModelOut, group.by = c('algo','run'))
bm_PlotEvalMean(bm.out = myBiomodModelOut)


#print variable importances

get_variables_importance(myBiomodModelOut, as.data.frame = TRUE)
apply(get_variables_importance(myBiomodModelOut), c(1,2), mean)

#individual model response plot

bm_PlotResponseCurves(bm.out = myBiomodModelOut)
                      # models.chosen = get_built_models(myBiomodModelOut)[c(1)],
                      # fixed.var = 'median')


###RUN ENSEMBLE modelling
#BIOMOD_EnsembleModeling combines individual models to build some kind of meta-model.
#for example, we decide to exclude models with TSS(AUC) less than 0.8
myBiomodEM <- BIOMOD_EnsembleModeling(
  myBiomodModelOut,
  models.chosen = 'all',
  em.by='all',
  metric.select = c("KAPPA", "TSS", "ROC"),
  metric.eval = c("KAPPA", "TSS", "ROC"),
  metric.select.thresh = c(0.8,0.8,0.8),
  prob.mean = T,
  prob.cv = T,
  prob.ci = T,
  prob.ci.alpha = 0.05,
  prob.median = T,
  committee.averaging = T,
  prob.mean.weight = T,
  prob.mean.weight.decay = 'proportional' )



#get evaluation scores
myBiomodEMEval <- get_evaluations(myBiomodEM)
myBiomodEMEval


###MODEL PROJECTION
###prediction under current conditions
myBiomodProj <- BIOMOD_Projection(
  myBiomodModelOut,
  new.env = myExpl,
  proj.name = 'current',
  models.chosen = 'all',
  metric.binary = 'TSS',
  compress = 'xz',
  build.clamping.mask = F,
  output.format = '.grd')

myBiomodEnsembleProj <- BIOMOD_EnsembleForecasting(
  myBiomodEM,
  bm.proj = myBiomodProj,
  proj.name = 'current',
  models.chosen = 'all',
  metric.binary = 'TSS',
  compress = 'xz',
  build.clamping.mask = F,
  output.format = '.grd')


#only plotting the committee averaging and mean weight 
plot(myBiomodEnsembleProj,str.grep = 'EMca|EMwmean'). ##THIS IS YOUR CURRENT PROJECTION RESULT
plot(myBiomodEnsembleProj,str.grep = 'EMca')
plot(myBiomodEnsembleProj,str.grep = 'EMwmean')


###prediction under future conditions
#get future data
biofut <- getData('CMIP5', var='bio', res=10, rcp=45, model='NO', year=50, download=T) 
biofut <- crop(biofut, eu_ext)
biofut
names(biofut) #this may have names different from the current data, so you may need to change the name
bio <- sprintf("bio%d", 1:19)
names(biofut) <- bio
myExplFut <- stack(biofut$bio9,biofut$bio10,biofut$bio18)

myBiomodProjFuture <- BIOMOD_Projection(
  myBiomodModelOut,
  new.env = myExplFut,
  proj.name = 'future',
  models.chosen = 'all',
  metric.binary = 'TSS',
  compress = 'xz',
  build.clamping.mask = F,
  output.format = '.grd')

myBiomodEMProjFuture <- BIOMOD_EnsembleForecasting(
  myBiomodEM,
  bm.proj = myBiomodProjFuture,
  proj.name = 'future',
  models.chosen = 'all',
  metric.binary = 'TSS',
  compress = 'xz',
  build.clamping.mask = T,
  output.format = '.grd')

plot(myBiomodEMProjFuture,str.grep = 'EMca|EMwmean') ##THIS IS YOUR FUTURE PROJECTION RESULT


        ###we can also check how single models look like, 
        ###just in case some single model overrules the result of the others
#for example, we look at GAM
a = get_built_models(myBiomodModelOut)
b = grep("_GAM",a) 
c = a[b]
  ###prediction under current conditions
myBiomodProj_gam <- BIOMOD_Projection(
  myBiomodModelOut,
  new.env = myExpl,
  proj.name = 'current_gam',
  models.chosen = c,
  metric.binary = 'TSS',
  compress = 'xz',
  build.clamping.mask = F,
  output.format = '.grd')

plot(myBiomodProj_gam, str.grep = 'PA1_RUN3') #choose a PA trial and RUN to map # you can also map them all by not specifying any str.grep

  ####prediction for future conditions
myBiomodProjFuture_gam <- BIOMOD_Projection(
  myBiomodModelOut,
  new.env = myExplFut,
  proj.name = 'future_gam',
  models.chosen = c,
  metric.binary = 'TSS',
  compress = 'xz',
  build.clamping.mask = F,
  output.format = '.grd')

plot(myBiomodProjFuture_rf, str.grep = 'PA1_RUN2')
plot(myBiomodProjFuture_glm, str.grep = 'PA1_RUN1')
plot(myBiomodProjFuture_gam, str.grep = 'PA1_RUN3')



##you may want to COMPUTE SPECIES RANGE CHANGE (SRC)
#load binary projections

At_bin_projCurrent <- stack(
  c(
    ca="Athaliana.pw/proj_current/individual_projections/Athaliana.pw_EMcaByTSS_mergedAlgo_mergedRun_mergedData.grd",
    wm="Athaliana.pw/proj_current/individual_projections/Athaliana.pw_EMwmeanByTSS_mergedAlgo_mergedRun_mergedData.grd"
  )
)

At_bin_projFuture <- stack(
  c(
    ca="Athaliana.pw/proj_future/individual_projections/Athaliana.pw_EMcaByTSS_mergedAlgo_mergedRun_mergedData.grd",
    wm="Athaliana.pw/proj_future/individual_projections/Athaliana.pw_EMwmeanByTSS_mergedAlgo_mergedRun_mergedData.grd"
  )
)

##SRC current to 2050
SRC_curr_2050 <- BIOMOD_RangeSize(
  At_bin_projCurrent,
  At_bin_projFuture
)

SRC_curr_2050$Compt.By.Models

At_SRC_map <- SRC_curr_2050$Diff.By.Pixel
names(At_SRC_map) <- c("ca-cur-2050","wm-cur-2050")

my.aes <- seq(-2.5,1.5,1)
myColorKey <- list(
  at = my.aes,
  labels=list(
    labels=c("lost","pres","abs","gain"),
    at = my.aes[-1] - 0.5 ##where to print labels
  )
)

rasterVis::levelplot(
  At_SRC_map,
  main = "Weak primary dormancy range change",
  colorkey=myColorKey,
  col.regions=c("#f03b20","#99d8c9","#f0f0f0","#2ca25f"),
  layout=c(2,1)
)

